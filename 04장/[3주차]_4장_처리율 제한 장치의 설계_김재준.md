# **4장) 처리율 제한 장치의 설계**

## **왜 처리율을 제한해야하는가?**

- DoS 공격으로 인한 **자원 고갈 방지 가능**
    - **비용절감 가능**
- 추가 요청에 대한 처리를 제한하면 서버를 많이 두지 않아도 된다.
    - 제 3자에게 API 를 제공하면서 호출 횟수에 따라 과금을 결정하는 모델인 경우
- **서버 과부하를 막는다.**
    - 봇(bot) 에서 오는 트래픽이나 사용자의 잘못된 이용패턴으로 유발된 트래픽을 걸러낼수 있음
- **책 이외의 추가내용 및 의견**
    - 외부에서 bot 을 이용한 API 서버 호출이 많다면 백엔드서버의 캐쉬전략이 bot 때문에 망가지는 현상이 있을 수 있다.

따라서 API 제한을 이용하여 캐쉬전략이 망가지지 않도록 다른쪽 서버로 분배를 하던가 봇이 검색하는경우 캐쉬전략을 따로 가지도록 하여야한다.

## **처리율 제한 알고리즘**

- 토큰 버킷
- 누출 버킷

---

앞선 2개의 알고리즘과  나머지 3개의 알고리즘은

i) 접근 즉시 요청을 버릴수 있는가(임계치 상태인가를 알수있는가)?

ii) 값을 가져와서 확인해서 처리해야하는가로 나뉘는것 같습니다

---

- 고정 윈도 카운터
- 이동 윈도 로깅
- 이동 윈도 카운터

## **상세설계**

- 처리율 제한 장치를 어느 쪽에 배치할 것인가?
    - 서비스 API 서버 앞에 LB 가 있는경우 Host 정보로 카운팅 할시 백엔드서버가 받는 Host 는 LB 정보임으로 클라이언트를 식별할 수 있는 byPass 값으로 해야 할 것 같다.
    - 클라이언트와 서비스 API 사이에 미들웨어로 둔다.
- 처리가 제한된 요청들은 어떻게 처리할것인가?
    - 메세지 큐에 저장하여 추 후 재 처리방식
    - 버린다.

각 서비스에 성향에 맞게 처리하면 될 것 같다.

## 분산 환경에서의 처리율 제한 장치의 구현시 문제발생 포인트

### 경쟁 조건

1. 레디스 카운터의 값을 읽어온다.
2. 읽은 값이 임계치를 넘는치 확인한다.
3. 카운트를 증가시켜 레디스에 저장한다.

두 개의 쓰레드 또는 인스턴스 가 1번 동시에 읽고 나머지 동작을 한다면 최종카운트 증가량은  2 가 아닌 1 이다.

**해결방안**

- LOCK
    - 잠금방식을 사용하게 된다면 성능이 느려짐으로 고려해봐야한다.
- 루아스크립트
- 레디스 Sorted Set

### 동기화 이슈

- 분산 환경에서 각각의 서버마다 저장장소를 갖게되면 생기는 이슈
    - A 요청은 X 서버에 할당되어 관리되고있었지만
    - 재 요청 A 가 Y 서버로 이동했을때는 새로운 요청으로 인식

**해결방안**

- 고정세션(sticky session) 활용
- 중앙 집중형 데이터 저장소를 사용한다.

## 성능 최적화

- 데이터를 저장하고있는 센터와 멀리 떨어져 있다면 어쩔수 없이 지연시간이 발생한다.
    - 따라서 각 서비스하고있는 위치에 맞게 edge server 를 이용하자
- 최종일관성모델