# 웹 크롤러 설계
## 1. 개략적 설계
<img width="800" src="https://user-images.githubusercontent.com/60383031/154845467-3fe23806-e9ed-43b4-8d7a-f0e507179aa5.png">

- (01) 시작 URL ---> 미수집 URL 저장소 저장
- (02) URL 목록을 가져온다. ( From 미수집 URL 저장소 )
- (03) 도메인 이름 변환기 사용 ---> URL 로 부터 IP 주소 알아냄 ---> 웹 페이지 다운로드 
- (04) HTML 페이지 파싱 ---> 검증
- (05) 중복 컨텐츠 확인
- (06) 이미 저장소에 있는지 check ---> 이미 존재 ??? ---> 버림
- (07) HTML 페이지에서 링크 골라냄
- (08) 골라낸 링크 ---> URL 필터 전달
- (09) 남은 URL ---> 중복 URL 판별 단계 전달
- (10) 이미 처리한지 확인 ---> 이미 저장소에 있다면 ??? ---> 버림
- (11) 저장소에 없다면 ??? ---> URL 저장소에 저장, 미수집 URL 저장소에도 전달

<br>

#### 주요 용어 정리
- 시작 URL 집합: 웹 크롤러가 크롤링을 시작하는 출발점 집합 (예를들어 카테고리 별로 나누기도함)
- 미수집 URL 저장소: 다운로드할 URL 을 저장/관리 컴포넌트 
- 콘텐츠 파서: 파싱 & 검증 담당, 연산이 많기 떄문에 독립된 컴포넌트로 구현
- 콘첸츠 저장소: HTML 문서 저장, 대부분 디스크에 저장하지만 Hot 한 컨텐츠는 메모리에 


<br>

## 2. 상세 설계
### DFS vs BFS
#### DFS
- 그래프 크기가 클 경우 어느 정도로 깊숙이 가게 될지 가늠하기 어려움

### BFS
- 웹 크롤러는 보통 BFS 사용
- 하지만 몇 가지 문제점이 있음

<img width="800" src="https://user-images.githubusercontent.com/60383031/154845387-5414033a-ee20-4fc7-95d9-d953c337fd0f.png">

- 링크들을 병렬로 돌리게 되면 서버에 과부하를 줄 수 있다. (탐색하는 방식으로 크롤링 하는 것 자체가 과부하는 주는 것이 아닌가 싶다.)
- 따라서 URL 간에 우선순위를 둘 필요가 있다.

<br>

### Politeness
<img width="800" src="https://user-images.githubusercontent.com/60383031/154845026-ed584407-54a9-414c-b2b0-78b855adb384.png">

- 너무 많은 요청을 보내는 것은 impolite 하다.
- 때론 DoS 공격으로 간주된다.
- 그렇기 때문에 동일 웹사이트에는 한 번만 요청을 보내는 것을 원칙으로 한다.
- 호스트명 / 작업 스레드 사이의 관계를 유지하는 방식으로 문제를 해결한다.

<br>

#### 주요 용어 정리
- 큐 라우터: 같은 호스트에 속한 URL 은 언제나 같은 큐로 가도록 보장
- 매핑 테이블: 호스트 이름과 큐 사이의 관계를 보관하는 테이블
- 큐 선택기: 큐에서 URL 을 거내서 해당 큐에서 나온 URL 을 다운로드 하도록 --> 작업 스레드에 전달
- 작업스레드: 전달된 URL 다운로드 작업, 지연 시간 가능


<br>

### 우선순위
<img width="800" src="https://user-images.githubusercontent.com/60383031/154844942-a5bf84be-5afa-4bb4-98b3-2dd584ad48e6.png">

- 유용성에 따라 URL 을 나눌 필요가 있다.
- 페이지 랭크, 트래픽 양, 갱신 빈도 등 다양한 척도 사용
- 순위결정장치: URL 을 입력 -> 우선순위 계산

<img width="800" src="https://user-images.githubusercontent.com/60383031/154844878-99baca39-8bfc-4d63-8a13-f993e405ac18.png">

- 전면 큐: 우선순위 결정 과정 처리
- 후면 큐: 크롤러가 Politeness 하게 동작하도록 보증

<br>

### 성능 최적화 (분산 크롤링)
<img width="800" src="https://user-images.githubusercontent.com/60383031/154843767-79609881-8fa6-4fdd-bb1d-03e4ee924bde.png">

- 크롤링 작업을 여러 서버에 분산
- 각 서버는 여러 스레드를 돌려 크롤링 작업 진행

<br>

### 확장성
<img width="800" src="https://user-images.githubusercontent.com/60383031/154844666-706c86bc-8318-4a55-9df8-f2fd49632d8d.png">

- 새로운 형태의 콘텐츠를 쉽게 지원할 수 있도록 고려해야함
- (아마 설계할때 인터페이스로 확장성을 고려하여 설계해야될 것 같음)